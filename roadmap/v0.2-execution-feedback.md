# Version 0.2: Execution & Feedback
**Duration**: 2 weeks  
**Goal**: Complete feedback loop with real-time updates and results  
**Bundle Size Target**: <300KB (+100KB from v0.1)

## New Package Installations

### Week 3, Day 1: Real-time & Display
```bash
# Virtual scrolling for logs (essential for performance)
npm install react-virtuoso@^4.12.6

# Code display (users need to see code output)
npm install @uiw/react-codemirror@^4.23.12
npm install @codemirror/lang-javascript@^6.2.4
npm install @codemirror/lang-markdown@^6.3.2

# Markdown rendering for docs
npm install react-markdown@^10.1.0
npm install remark-gfm@^4.0.1

# Additional shadcn components
npx shadcn-ui@latest add badge progress tabs separator skeleton
```

### Week 3, Day 2: Data Fetching
```bash
# Now we need proper data management
npm install @tanstack/react-query@^5.50.0
npm install zustand@^5.0.3

# Utilities
npm install date-fns@^4.1.0
```

## Phase 2.1: Real-time Job Status (Days 11-13)

### User Story
"As a user, I want to see the status of my running job and any logs in real-time."

### Implementation Steps

#### 1. Extend Convex Schema
```typescript
// convex/schema.ts - additions
messages: defineTable({
  jobId: v.id("jobs"),
  content: v.string(),
  type: v.union(
    v.literal("log"),
    v.literal("tool"),
    v.literal("error")
  ),
  timestamp: v.number(),
}).index("by_job", ["jobId"]),
```

#### 2. Setup React Query
```typescript
// app/providers.tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ConvexProvider, ConvexReactClient } from 'convex/react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ConvexProvider client={convex}>
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </ConvexProvider>
  );
}
```

#### 3. Job Detail Page with Virtual Scrolling
```typescript
// app/(dashboard)/jobs/[id]/page.tsx
'use client';

import { useQuery } from 'convex/react';
import { Virtuoso } from 'react-virtuoso';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { api } from '@/convex/_generated/api';

export default function JobDetailPage({ params }) {
  const job = useQuery(api.jobs.get, { id: params.id });
  const messages = useQuery(api.messages.list, { jobId: params.id });

  return (
    <div className="container mx-auto p-6">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-bold">Job Details</h1>
        <Badge variant={getStatusVariant(job?.status)}>
          {job?.status}
        </Badge>
      </div>

      {job?.status === 'running' && (
        <Progress value={33} className="mb-4" />
      )}

      <Tabs defaultValue="logs" className="w-full">
        <TabsList>
          <TabsTrigger value="logs">Logs</TabsTrigger>
          <TabsTrigger value="output">Output</TabsTrigger>
        </TabsList>
        
        <TabsContent value="logs" className="h-[500px]">
          <div className="border rounded-lg bg-slate-950 text-slate-50 p-4 h-full">
            <Virtuoso
              data={messages}
              itemContent={(index, message) => (
                <div className="font-mono text-sm py-1">
                  <span className="text-slate-500">
                    {new Date(message.timestamp).toLocaleTimeString()}
                  </span>
                  {' '}
                  <span>{message.content}</span>
                </div>
              )}
              followOutput="smooth"
            />
          </div>
        </TabsContent>
        
        <TabsContent value="output">
          {/* Output will be added in next phase */}
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

#### 4. Webhook Handler in Convex
```typescript
// convex/http.ts
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

http.route({
  path: "/webhook/job-update",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    const token = request.headers.get("X-Job-Token");
    const body = await request.json();
    
    // Simple token validation for v0.2
    const job = await ctx.runQuery(internal.jobs.getByToken, {
      token,
      jobId: body.jobId,
    });
    
    if (!job) {
      return new Response("Unauthorized", { status: 401 });
    }
    
    // Store message
    await ctx.runMutation(internal.messages.add, {
      jobId: body.jobId,
      content: body.content,
      type: body.type,
    });
    
    if (body.type === 'complete') {
      await ctx.runMutation(internal.jobs.updateStatus, {
        jobId: body.jobId,
        status: 'completed',
      });
    }
    
    return new Response("OK", { status: 200 });
  }),
});

export default http;
```

### Acceptance Criteria
- [ ] Real-time log streaming works
- [ ] Virtuoso handles 1000+ log lines
- [ ] Status badge updates automatically
- [ ] Progress indicator shows activity

## Phase 2.2: Result Display (Days 14-16)

### Implementation

#### 1. File Storage Integration
```typescript
// convex/files.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const uploadResult = mutation({
  args: {
    jobId: v.id("jobs"),
    fileName: v.string(),
    content: v.string(),
    mimeType: v.string(),
  },
  handler: async (ctx, args) => {
    // Store file content
    const storageId = await ctx.storage.store(
      new Blob([args.content], { type: args.mimeType })
    );
    
    // Update job with output reference
    await ctx.db.patch(args.jobId, {
      outputs: [...(job.outputs || []), {
        fileName: args.fileName,
        storageId,
        mimeType: args.mimeType,
      }],
    });
    
    return storageId;
  },
});
```

#### 2. Code Display Component
```typescript
// components/code-viewer.tsx
import CodeMirror from '@uiw/react-codemirror';
import { javascript } from '@codemirror/lang-javascript';
import { markdown } from '@codemirror/lang-markdown';

export function CodeViewer({ content, language }) {
  const extensions = language === 'markdown' 
    ? [markdown()] 
    : [javascript()];
  
  return (
    <CodeMirror
      value={content}
      height="400px"
      theme="dark"
      extensions={extensions}
      editable={false}
    />
  );
}
```

#### 3. Markdown Preview
```typescript
// components/markdown-preview.tsx
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

export function MarkdownPreview({ content }) {
  return (
    <div className="prose prose-slate dark:prose-invert max-w-none">
      <ReactMarkdown remarkPlugins={[remarkGfm]}>
        {content}
      </ReactMarkdown>
    </div>
  );
}
```

## Phase 2.3: Error Handling (Days 17-18)

### Implementation

#### 1. Error Boundary
```typescript
// components/error-boundary.tsx
'use client';

import { Component } from 'react';
import { Button } from '@/components/ui/button';

export class ErrorBoundary extends Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="p-6 text-center">
          <h2 className="text-xl font-semibold mb-4">Something went wrong</h2>
          <Button onClick={() => window.location.reload()}>
            Reload Page
          </Button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

#### 2. Job Retry
```typescript
// convex/jobs.ts
export const retry = mutation({
  args: { jobId: v.id("jobs") },
  handler: async (ctx, args) => {
    const job = await ctx.db.get(args.jobId);
    if (!job || job.status !== 'failed') {
      throw new Error("Cannot retry this job");
    }
    
    // Create new job with same config
    const newJobId = await ctx.db.insert("jobs", {
      ...job,
      status: "pending",
      callbackToken: generateToken(),
      createdAt: Date.now(),
      parentJobId: args.jobId,
    });
    
    // Trigger execution
    await triggerCloudRun(newJobId, job);
    
    return newJobId;
  },
});
```

## Testing Checklist

### Performance
- [ ] Bundle size <300KB
- [ ] Virtuoso renders 10,000 lines smoothly
- [ ] No memory leaks with long-running jobs
- [ ] WebSocket reconnection works

### Functionality
- [ ] Logs stream in real-time
- [ ] Code syntax highlighting works
- [ ] Markdown renders correctly
- [ ] Error recovery functions

## Cloud Run Updates

### Enhanced Server (Week 4)
```javascript
// server.js - Now with real execution
const { spawn } = require('child_process');

class BatchedUpdater {
  constructor(callbackUrl, jobId, token) {
    this.callbackUrl = callbackUrl;
    this.jobId = jobId;
    this.token = token;
    this.buffer = [];
    this.timer = null;
  }
  
  append(data) {
    this.buffer.push({
      content: data.toString(),
      timestamp: Date.now(),
    });
    
    if (this.buffer.length >= 10 || !this.timer) {
      this.timer = setTimeout(() => this.flush(), 500);
    }
  }
  
  async flush() {
    if (this.buffer.length === 0) return;
    
    const messages = [...this.buffer];
    this.buffer = [];
    
    await fetch(this.callbackUrl, {
      method: 'POST',
      headers: {
        'X-Job-Token': this.token,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        jobId: this.jobId,
        type: 'message_batch',
        messages,
      }),
    });
  }
}

app.post('/execute', async (req, res) => {
  const { jobId, command, prompt, callbackUrl, callbackToken } = req.body;
  const updater = new BatchedUpdater(callbackUrl, jobId, callbackToken);
  
  const child = spawn('node', ['cli.bundled.cjs', 'run', '-p', prompt]);
  
  child.stdout.on('data', (data) => updater.append(data));
  child.stderr.on('data', (data) => updater.append(data));
  
  child.on('exit', async (code) => {
    await updater.flush();
    await fetch(callbackUrl, {
      method: 'POST',
      headers: { 'X-Job-Token': callbackToken },
      body: JSON.stringify({
        jobId,
        type: 'complete',
        exitCode: code,
      }),
    });
  });
  
  res.json({ status: 'started', jobId });
});
```

## Success Metrics
- Real-time update latency <500ms
- Log rendering performance >60fps
- Code viewer loads <1s
- Error recovery success >80%

## Next Steps
â†’ Continue to [v0.3 - User Experience](./v0.3-user-experience.md)